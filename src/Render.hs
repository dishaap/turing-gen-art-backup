module Render
    ( rendermain,
      drawPicture,
      turingGen,
      currStateGeneration,
      flattenTM,
      -- actionArrGen,
      --actionGen,
      --ruleArrGen,
      --ruleGen,
      currStateGeneration,
      symbGeneration
    ) where

    import Graphics.Gloss
    import TuringMachine
    import NumberGenerator
    import Data.ByteString
    import Data.Word

    -- global variables to define the number of states and symbols constant across all iterations. initialises a turing machine
    -- that will act as the beginning for iterations.
    numStates = 1
    numSymbols = 1
    tm = blankInit (256, 256) (TuringMachine.Symbol 1)
    tmtransition = [[]]
    
    -- call for animation rendered. takes number of iterations of turing machine, number of states and symbols
    -- from the user and produces an animation of 256 x 256 pixels representing the iterations of the turing machine
    rendermain :: Float -> Int -> Int -> IO ()
    rendermain num states symbols = 
        do
            let numStates = states
            let numSymbols = symbols

            anim <- animate (InWindow "Turing Generative Art" (256, 256) (0,0)) black drawPicture

            return anim

    -- returns a single frame of the animation, dependent on the number of frames specified by user. set as 20.
    -- calls turingGen, which generates the next turingMachine, for the number of frames specified. 
    -- byteStrings are generated for each of these list of states which is converted
    -- into a bitmap using drawPicture and returned to animate as a frame.
    drawPicture :: Float -> Picture
    drawPicture num = bitmapOfByteString 256 256 (BitmapFormat TopToBottom PxRGBA) (currStateGeneration (flattenTM (turingGen tm))) True
    
    -- generates a new turing machine for the current iteration when called by mapping the transitions generated by transInit 
    -- onto the current states in the turing machine to update them
    -- TBD -- the logic for generating a new turing machine
    turingGen :: TuringMachine -> TuringMachine
    turingGen tm1 = turingGenHelper1 (transInit tm1 (actionArrGen 256 256) (ruleArrGen 256 256) (256, 256) (0, 0))

    turingGenHelper1 :: [[Transition]] -> TuringMachine
    turingGenHelper1 [] = []
    turingGenHelper1 (transition : transitions) = (turingGenHelper2 transition) : (turingGenHelper1 transitions)

    turingGenHelper2 :: [Transition] -> [State]
    turingGenHelper2 [] = []
    turingGenHelper2 (transition : transitions) = (fstTrans transition) : (turingGenHelper2 transitions)

    -- flattens 2-d turingmachine into [State]
    flattenTM :: TuringMachine -> [State]
    flattenTM tm1 = [x | y <- tm1, x <- y]

    -- generate a list of list of randomly generated actions equal to the dimensions of the given turingmachine
    -- using actionGen
    actionArrGen :: Float -> Float -> IO [[Action]]
    actionArrGen w h = 
        do
            actlist <- [[actionIOGen | j <- [1..h]] | i <- [1..w]]
            return actlist

    -- actionIOGen :: IO Action
    actionIOGen =
        do
            n <- randInt 4
            return (actionGen n)
    
    actionGen n
        | n == 1 = moveUp
        | n == 2 = moveDown
        | n == 3 = moveRight
        | n == 4 = moveLeft

    -- similar to actionArrGen generate a list of list of randomly generated rules equal to the dimensions of the given 
    -- turingmachine using ruleGen
    ruleArrGen w h = 
        do
            actlist <- [[ruleIOGen | j <- [1..h]] | i <- [1..w]]
            return actlist

    ruleIOGen =
        do
            n <- randInt 4
            return (ruleGen n)

    ruleGen n
        | n == 1 = sub1
        | n == 2 = add1
        | n == 3 = sub2
        | n == 4 = add2
        | otherwise = add0

    -- NOT SURE IF THE CURRENT BYTESTRING/WORD8 FUNCTIONALITY WORKS NEED TO TEST
    -- for a given list of states, generate a ByteString of all the specified symbols by calling symbGeneration on all the symbols
    -- present in the current turing machine
    -- problem: turingGen will return [[State]] -> i need [State]. helper fix probably.
    currStateGeneration :: [State] -> ByteString
    currStateGeneration currstate = pack $ Prelude.foldr (++) [] (Prelude.map symbGeneration (Prelude.map (third) currstate))
    
    -- generate a symbol of a particular color according to the one assigned in the current state
    symbGeneration :: Symbol -> [Word8]
    symbGeneration (Symbol n)
        | n == 1 = [255, 0, 0, 255] -- red
        | n == 2 = [0, 255, 0, 255] -- green
        | n == 3 = [0, 0, 255, 255] -- blue
        | n == 4 = [255, 255, 0, 255] -- yellow
        | n == 5 = [0, 255, 255, 255] -- cyan
        | otherwise = [0, 0, 0, 255] -- revert to black